<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[sunxb10's blog]]></title>
  <subtitle><![CDATA[Blogging = Hexo + Markdown + Git + GitHub Pages]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxb10.github.io/"/>
  <updated>2015-04-01T15:39:48.524Z</updated>
  <id>http://sunxb10.github.io/</id>
  
  <author>
    <name><![CDATA[sunxb10]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Vim初学笔记]]></title>
    <link href="http://sunxb10.github.io/2015/03/31/my-first-vim-note/"/>
    <id>http://sunxb10.github.io/2015/03/31/my-first-vim-note/</id>
    <published>2015-03-31T04:55:33.000Z</published>
    <updated>2015-04-01T15:24:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Vim的模式">Vim的模式</h2>
<p>按照帮助文档（<code>:help vim-modes</code>）的说法，Vim共有12种模式，包括6种基本模式和6种派生模式；作为初学者，至少要掌握其中5种模式：普通模式（Normal）、插入模式（Insert）、改写模式（Replace）、命令行模式（Cmdline）和可视模式（Visual）。充分了解这5种模式的区别并熟练掌握这些模式间的转换应当是每一位Vim使用者的基本功：<br><a id="more"></a></p>
<ul>
<li><strong>普通模式</strong>（Normal）：此模式是Vim最重要最常用的模式，也是其它各模式间转换的中间桥梁。Vim启动后默认即为普通模式，在其它模式下按<code>ESC</code>键可进入普通模式。进入此模式后Vim下方命令行无提示。</li>
<li><strong>插入模式</strong>（Insert）：此模式下可直接输入所需的文本内容，这可能是初学者最熟悉的模式。在普通模式下按<code>i</code>、<code>I</code>、<code>a</code>、<code>A</code>、<code>o</code>、<code>O</code>、<code>c</code>、<code>C</code>、<code>s</code>或<code>S</code>键可进入插入模式。进入此模式后Vim下方命令行出现提示<code>-- INSERT --</code>。</li>
<li><strong>改写模式</strong>（Replace）：此模式与插入模式类似，不同之处在于此模式是改写已有文本而非直接插入。在普通模式下按<code>R</code>键可进入改写模式。进入此模式后Vim下方命令行出现提示<code>-- REPLACE --</code>。</li>
<li><strong>命令行模式</strong>（Cmdline）：此模式下可在Vim下方命令行中输入指令，按回车键后执行。在普通模式下按<code>:</code>、<code>?</code>或<code>/</code>键可进入命令行模式。进入此模式后Vim下方命令行中显示用户输入的指令内容（包括为转换模式而输入的<code>:</code>、<code>?</code>和<code>/</code>）。</li>
<li><strong>可视模式</strong>（Visual）：此模式下可用光标移动指令高亮选择文本块进行编辑。在普通模式下按<code>v</code>、<code>V</code>或<code>^V</code>可进入可视模式。进入此模式后Vim下方命令行中出现提示<code>-- VISUAL --</code>，此时移动光标即可高亮选择文本，输入任意非移动指令（包括<code>v</code>、<code>V</code>和<code>^V</code>）可返回普通模式。</li>
</ul>
<p>上面出现的<code>^V</code>实际上是指组合键<code>Ctrl</code>+<code>V</code>，因为Vim右下方状态栏会以字符<code>^</code>表示用户按下的<code>Ctrl</code>键。另外，对于MS-Windows下的gVim而言，使用<code>Ctrl</code>+<code>V</code>无法正确进入可视模式，因为该组合键被gVim默认映射为粘贴操作。这无疑是一个非常不合适的设定，因为<code>Ctrl</code>+<code>V</code>所进入的是矩形选择的可视模式，该模式允许用户通过移动光标方便高效地选择矩形文本块，故这里强烈建议更改gVim的默认映射设定，具体方法是在gVim的安装目录中打开<code>/vim74/mswin.vim</code>文件，找到如下片段：</p>
<figure class="highlight VimL"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">" CTRL-V and SHIFT-Insert are Paste</span></div><div class="line"><span class="built_in">map</span> &lt;C-V&gt;		<span class="string">"+gP</span></div><div class="line"><span class="built_in">map</span> &lt;S-Insert&gt;		"+gP</div></pre></td></tr></table></figure>

<p>将其修改为</p>
<figure class="highlight VimL"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">" CTRL-V and SHIFT-<span class="operator"><span class="keyword">Insert</span> <span class="keyword">are</span> Paste</span></div><div class="line"><span class="string">" map &lt;C-V&gt;		"</span>+gP</div><div class="line">map &lt;S-<span class="keyword">Insert</span>&gt;		<span class="string">"+gP</span></div></pre></td></tr></table></figure>

<p>保存该文件并重启gVim即可，此后在gVim中可使用<code>Shift</code>+<code>Insert</code>组合键进行粘贴操作。</p>
<h2 id="Vim_Cheatsheet">Vim Cheatsheet</h2>
<p>在互联网上能找到很多的Vim cheatsheet（点击<a href="http://vim.rtorr.com/lang/zh_cn/" target="_blank" rel="external">这里</a>和<a href="http://www.fprintf.net/vimCheatSheet.html" target="_blank" rel="external">这里</a>）以及Vim键盘映射图（点击<a href="http://www.cnblogs.com/JessonChan/archive/2010/11/25/1888020.html" target="_blank" rel="external">这里</a>和<a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="external">这里</a>），这些高人们制作的图表在完整性和准确性上自然是难以挑剔，对于我们学习Vim肯定是大有裨益；但同时应当注意到Vim支持指令的缩写和简写，故网上cheatsheet和教程中大量的指令都只是一两个字母或组合键，缺乏经验的初学者很难从指令的字面推断出该指令的具体含义。因此我在下面的Vim cheatsheet中专门加入了各指令的英文全称，有英语基础的学习者可利用这些英文词汇帮助记忆表中各条Vim指令：</p>
<h3 id="编辑、保存与退出">编辑、保存与退出</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:w</code></td>
<td><strong>w</strong>rite</td>
<td>将缓存区内容写入文件，即保存改动</td>
</tr>
<tr>
<td><code>:q</code></td>
<td><strong>q</strong>uit</td>
<td>退出Vim</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td><strong>q</strong>uit</td>
<td>放弃未保存的改动并退出Vim</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td><strong>w</strong>rite &amp; <strong>q</strong>uit</td>
<td>保存改动并退出Vim</td>
</tr>
<tr>
<td><code>:e [file]</code></td>
<td><strong>e</strong>dit</td>
<td>编辑文件[file]，如未指定文件名则重新载入并编辑当前文件</td>
</tr>
<tr>
<td><code>:r {file}</code></td>
<td><strong>r</strong>ead</td>
<td>将文件{file}的内容插入到当前光标后</td>
</tr>
<tr>
<td><code>gf</code></td>
<td><strong>g</strong>oto <strong>f</strong>ile</td>
<td>根据光标悬停处的文件名打开当前路径下的对应文件</td>
</tr>
</tbody>
</table>
<h3 id="光标移动">光标移动</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>—</td>
<td>左移光标（字母h在hjkl中排在最左边）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>—</td>
<td>下移光标（字母j看起来像一个向下的箭头）</td>
</tr>
<tr>
<td><code>k</code></td>
<td>—</td>
<td>上移光标</td>
</tr>
<tr>
<td><code>l</code></td>
<td>—</td>
<td>右移光标（字母l在hjkl中排在最右边）</td>
</tr>
<tr>
<td><code>0</code></td>
<td>—</td>
<td>当前行行首</td>
</tr>
<tr>
<td><code>^</code></td>
<td>—</td>
<td>当前行行首非空格字符</td>
</tr>
<tr>
<td><code>$</code></td>
<td>—</td>
<td>当前行行尾</td>
</tr>
<tr>
<td><code>[line]G</code></td>
<td><strong>g</strong>oto line</td>
<td>跳转到第[line]行行首非空格字符，如未指定行号则跳转到文档末行</td>
</tr>
<tr>
<td><code>[line]gg</code></td>
<td><strong>g</strong>oto line</td>
<td>跳转到第[line]行行首非空格字符，如未指定行号则跳转到文档首行</td>
</tr>
<tr>
<td><code>[count]+</code></td>
<td>—</td>
<td>向下跳转[count]行到行首非空格字符，如未指定行数则跳转到下一行</td>
</tr>
<tr>
<td><code>[count]-</code></td>
<td>—</td>
<td>向上跳转[count]行到行首非空格字符，如未指定行数则跳转到上一行</td>
</tr>
<tr>
<td><code>w</code></td>
<td><strong>w</strong>ords forward</td>
<td>移动到下个word开头</td>
</tr>
<tr>
<td><code>W</code></td>
<td><strong>W</strong>ORDS forward</td>
<td>移动到下个WORD开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>forward to <strong>e</strong>nd of words</td>
<td>移动到下个word末尾</td>
</tr>
<tr>
<td><code>E</code></td>
<td>forward to <strong>e</strong>nd of WORDS</td>
<td>移动到下个WORD末尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>words <strong>b</strong>ackward</td>
<td>移动到上个word开头</td>
</tr>
<tr>
<td><code>B</code></td>
<td>WORDS <strong>b</strong>ackward</td>
<td>移动到上个WORD开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td><strong>g</strong>o backwards to <strong>e</strong>nd of words</td>
<td>移动到上个word末尾</td>
</tr>
<tr>
<td><code>gE</code></td>
<td><strong>g</strong>o backwards to <strong>e</strong>nd of WORDS</td>
<td>移动到上个WORD末尾</td>
</tr>
<tr>
<td><code>f{char}</code></td>
<td><strong>f</strong>orward to occurrence of {char}</td>
<td>将光标向右移动到本行中的{char}字符上</td>
</tr>
<tr>
<td><code>F{char}</code></td>
<td><strong>f</strong>orward to occurrence of {char}</td>
<td>将光标向左移动到本行中的{char}字符上</td>
</tr>
<tr>
<td><code>t{char}</code></td>
<td><strong>t</strong>ill before occurrence of {char}</td>
<td>将光标向右移动到本行中的{char}字符前</td>
</tr>
<tr>
<td><code>T{char}</code></td>
<td><strong>t</strong>ill before occurrence of {char}</td>
<td>将光标向左移动到本行中的{char}字符前</td>
</tr>
<tr>
<td><code>;</code></td>
<td>—</td>
<td>按照之前的方向重复f、F、t或T操作</td>
</tr>
<tr>
<td><code>,</code></td>
<td>—</td>
<td>按照与之前相反的方向重复f、F、t或T操作</td>
</tr>
</tbody>
</table>
<p>表中word与WORD的区别在于：word以标点（不包括数字和下划线）或空白（空格、Tab、换行符等）结尾，而WORD只以空白结尾。例如字符串<code>vim7:best_editor ever</code>，用<code>w</code>跳转（word）会分成4段：<code>vim7</code>、<code>:</code>、<code>best_editor</code>和<code>ever</code>，而用<code>W</code>跳转（WORD）则只有2段：<code>vim7:best_editor</code>、<code>ever</code>。由于英文标点属于半角符号，故通常会在每个英文标点后空一格，不会像这个例子这样写的这么紧凑，所以这两种跳转方式的推进速度差不太多。但在中文环境下这二者就会有极为明显的差别：中文标点是全角符号，一般不会再加空格，因此常常出现一大段中文文本中根本就没有任何空白字符的情况，这时如果使用<code>W</code>跳转（WORD）就会从段首直接跳到下一段，而使用<code>w</code>跳转（word）则只会从段首跳到段内第一个标点符号处。</p>
<h3 id="插入与改写">插入与改写</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td><strong>i</strong>nsert</td>
<td>在当前光标前插入文本</td>
</tr>
<tr>
<td><code>I</code></td>
<td><strong>i</strong>nsert</td>
<td>在当前行行首非空格字符前插入文本</td>
</tr>
<tr>
<td><code>a</code></td>
<td><strong>a</strong>ppend</td>
<td>在当前光标后追加文本</td>
</tr>
<tr>
<td><code>A</code></td>
<td><strong>a</strong>ppend</td>
<td>在当前行行尾追加文本</td>
</tr>
<tr>
<td><code>o</code></td>
<td><strong>o</strong>pen new line</td>
<td>在当前行下方插入新一行文本</td>
</tr>
<tr>
<td><code>O</code></td>
<td><strong>o</strong>pen new line</td>
<td>在当前行上方插入新一行文本</td>
</tr>
<tr>
<td><code>r{char}</code></td>
<td><strong>r</strong>eplace</td>
<td>将当前选定字符改为{char}</td>
</tr>
<tr>
<td><code>R</code></td>
<td><strong>r</strong>eplace</td>
<td>进入改写模式</td>
</tr>
<tr>
<td><code>~</code></td>
<td>—</td>
<td>切换当前选定字符的大小写</td>
</tr>
<tr>
<td><code>~{motion}</code></td>
<td>—</td>
<td>切换光标移动指令{motion}所选定字符的大小写</td>
</tr>
<tr>
<td><code>s</code></td>
<td><strong>s</strong>ubstitute</td>
<td>删除当前字符，并进入插入模式</td>
</tr>
<tr>
<td><code>S</code></td>
<td><strong>s</strong>ubstitute</td>
<td>清空当前行，并进入插入模式，等价于<code>cc</code></td>
</tr>
<tr>
<td><code>c{motion}</code></td>
<td><strong>c</strong>hange</td>
<td>将光标移动指令{motion}选定的字符删除，并进入插入模式</td>
</tr>
<tr>
<td><code>cc</code></td>
<td><strong>c</strong>hange</td>
<td>清空当前行，并进入插入模式，等价于<code>S</code></td>
</tr>
</tbody>
</table>
<h3 id="删除文本">删除文本</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>—</td>
<td>删除当前选定字符（这里的“删除”其实是“剪切”，下同）</td>
</tr>
<tr>
<td><code>X</code></td>
<td>—</td>
<td>删除当前选定字符之前的字符</td>
</tr>
<tr>
<td><code>d{motion}</code></td>
<td><strong>d</strong>elete</td>
<td>将光标移动指令{motion}选定的文本删除</td>
</tr>
<tr>
<td><code>dd</code></td>
<td><strong>d</strong>elete</td>
<td>删除当前行</td>
</tr>
<tr>
<td><code>:[range]d</code></td>
<td><strong>d</strong>elete</td>
<td>删除指定行号范围[range]内的文本行，如未指定范围则删除当前行</td>
</tr>
<tr>
<td><code>J</code></td>
<td><strong>j</strong>oin</td>
<td>将下一行接到本行之后，即删除换行符</td>
</tr>
</tbody>
</table>
<p>其中Vim行号范围<code>[range]</code>的格式为<code>m</code>（第m行）或<code>m,n</code>（第m行到第n行），除行号数字外还可使用以下符号：</p>
<ul>
<li><code>.</code>：当前行</li>
<li><code>$</code>：文档末行</li>
<li><code>%</code>：文档所有行，等价于<code>1,$</code></li>
<li><code>/{pattern}/</code>：从当前行向下查找到包含{pattern}的第一行，参见<a href="#search-and-replace">查找与替换</a></li>
<li><code>?{pattern}?</code>：从当前行向上查找到包含{pattern}的第一行，参见<a href="#search-and-replace">查找与替换</a></li>
</ul>
<h3 id="复制与粘贴">复制与粘贴</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>y{motion}</code></td>
<td><strong>y</strong>ank</td>
<td>复制光标移动指令{motion}选定的文本</td>
</tr>
<tr>
<td><code>yy</code></td>
<td><strong>y</strong>ank</td>
<td>复制当前行</td>
</tr>
<tr>
<td><code>:[range]y</code></td>
<td><strong>y</strong>ank</td>
<td>复制指定行号范围[range]内的文本行，如未指定范围则复制当前行</td>
</tr>
<tr>
<td><code>p</code></td>
<td><strong>p</strong>ut</td>
<td>在光标后粘贴</td>
</tr>
<tr>
<td><code>P</code></td>
<td><strong>p</strong>ut</td>
<td>在光标前粘贴</td>
</tr>
<tr>
<td><code>:[line]pu</code></td>
<td><strong>p</strong>ut</td>
<td>粘贴到[line]行之后，如未指定行号则粘贴到当前行后</td>
</tr>
<tr>
<td><code>:[line]pu!</code></td>
<td><strong>p</strong>ut</td>
<td>粘贴到[line]行之前，如未指定行号则粘贴到当前行前</td>
</tr>
</tbody>
</table>
<p>Vim中复制粘贴指令的英文全称看起来可能略有些奇怪，居然不是copy/paste，而是yank/put。之所以选这两个词是因为它们描述了Vim在进行复制粘贴操作时的寄存器动作：Vim本身提供了一组寄存器，其复制和删除（其实是剪切）操作就是把选定的文本从缓存区抽取到寄存器中，而yank这个单词的意思正是“抽，拉”；反过来，Vim进行粘贴操作时则是把寄存器中的文本放到缓存区中，put的意思也正是“放，推”。</p>
<h3 id="撤销与重做">撤销与重做</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>u</code></td>
<td><strong>u</strong>ndo</td>
<td>撤销</td>
</tr>
<tr>
<td><code>:u</code></td>
<td><strong>u</strong>ndo</td>
<td>撤销</td>
</tr>
<tr>
<td><code>^R</code></td>
<td><strong>r</strong>edo</td>
<td>重做</td>
</tr>
<tr>
<td><code>.</code></td>
<td>—</td>
<td>重复执行上一条指令</td>
</tr>
</tbody>
</table>
<p><a name="search-and-replace"></a></p>
<h3 id="查找与替换">查找与替换</h3>
<table>
<thead>
<tr>
<th>Vim指令</th>
<th>英文全称</th>
<th>指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/{pattern}</code></td>
<td>—</td>
<td>向下查找{pattern}</td>
</tr>
<tr>
<td><code>?{pattern}</code></td>
<td>—</td>
<td>向上查找{pattern}</td>
</tr>
<tr>
<td><code>n</code></td>
<td><strong>n</strong>ext</td>
<td>跳转到下一条查找结果</td>
</tr>
<tr>
<td><code>N</code></td>
<td><strong>n</strong>ext</td>
<td>跳转到上一条查找结果</td>
</tr>
<tr>
<td><code>:nohl</code></td>
<td><strong>no</strong> <strong>h</strong>igh<strong>l</strong>ight</td>
<td>关闭查找结果的高亮显示</td>
</tr>
<tr>
<td><code>:[range]s/{pattern}/{string}/[flag]</code></td>
<td><strong>s</strong>ubstitute</td>
<td>将指定行号范围[range]内各行中的{pattern}替换为{string}，如未指定范围则仅对当前行操作，[flag]是可选标志位</td>
</tr>
<tr>
<td><code>:[range]s [flag]</code></td>
<td><strong>s</strong>ubstitute</td>
<td>沿用上次替换的{pattern}和{string}继续进行替换，等价于<code>:&amp;</code>，注意此操作不会沿用前次标志位设定</td>
</tr>
<tr>
<td><code>:[range]&amp; [flag]</code></td>
<td>—</td>
<td>沿用上次替换的{pattern}和{string}继续进行替换，等价于<code>:s</code>，注意此操作不会沿用前次标志位设定</td>
</tr>
</tbody>
</table>
<p>替换操作中的可选标志位<code>flag</code>相当于该指令的参数，用户可根据需求同时使用多个互不冲突的标志位。常用标志位的功能如下表所示：</p>
<ul>
<li><code>&amp;</code>：沿用上次替换操作的标志位设置，如使用<code>&amp;</code>则必须将其置于其它标志位之前，如<code>:&amp;&amp;</code>、<code>:%s/he/she/&amp;pI</code></li>
<li><code>c</code>：<strong>c</strong>onfirm，每次替换前均请求确认</li>
<li><code>e</code>：<strong>e</strong>rror，禁止打印错误信息</li>
<li><code>g</code>：<strong>g</strong>lobal，替换所有{pattern}的匹配，如无此标志则仅替换每行中第一个匹配</li>
<li><code>i</code>；<strong>i</strong>gnore case，匹配{pattern}时不区分大小写</li>
<li><code>I</code>：<strong>i</strong>gnore case，匹配{pattern}时区分大小写</li>
<li><code>p</code>：<strong>p</strong>rint，打印包含最后一处替换的文本行</li>
<li><code>n</code>：<strong>n</strong>umber，不执行替换，仅显示找到的{patter}匹配数</li>
</ul>
<p>需要指出的是，Vim的查找（包括替换操作中的查找）本身已支持正则表达式，因此在查找和替换一些特殊符号时需要加转义符<code>\</code>，比如：</p>
<ul>
<li><code>/[range]</code>：向下查找字母r、a、n、g和e，这五个字母中任何一个都可以匹配<code>[range]</code></li>
<li><code>/\[range\]</code>：向下查找字符串“[range]”，只有这个由一对中括号和单词range构成的字符串能够唯一地匹配<code>\[range\]</code></li>
</ul>
<h2 id="Vim配置">Vim配置</h2>
<p>以下是一套面向初学者的Vim配置（含详细注释）：</p>
<figure class="highlight VimL"><figcaption><span>.vimrc</span><a href="https://gist.github.com/sunxb10/5f98c2052ed5d714389a" target="_blank" rel="external">gist snippet</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="string">" ==================== Vim 通用设置 =======================</span></div><div class="line"></div><div class="line">set nocompatible  <span class="string">" 禁用vi兼容模式</span></div><div class="line"></div><div class="line">set number  <span class="string">" 显示行号</span></div><div class="line">set ruler  <span class="string">" 显示标尺</span></div><div class="line">set showmatch  <span class="string">" 输入括号时短暂跳转到匹配括号</span></div><div class="line"></div><div class="line">set confirm  <span class="string">" 在需要时提醒用户处理未保存的修改</span></div><div class="line">set nobackup  <span class="string">" 覆盖文件时不生成原文件备份</span></div><div class="line">set noswapfile  <span class="string">" 禁用swap文件（编辑的文件大小远小于电脑物理内存时不需要swap文件）</span></div><div class="line"></div><div class="line">set magic  <span class="string">" 开启Vim正则表达式的magic模式</span></div><div class="line">set ignorecase  <span class="string">" 设置Vim在搜索时默认不区分大小写</span></div><div class="line">set incsearch  <span class="string">" 输入搜索关键词时实时高亮显示匹配结果</span></div><div class="line"></div><div class="line">set autoindent  <span class="string">" 自动将当前行的缩进应用于下一行</span></div><div class="line">set smartindent  <span class="string">" 在autoindent的基础上进行智能缩进</span></div><div class="line">set tabstop=<span class="number">4</span>  <span class="string">" 设定&lt;Tab&gt;的宽度等于4个空格</span></div><div class="line">set expandtab  <span class="string">" 与上一条指令配合将输入的&lt;Tab&gt;转换为指定数量的空格</span></div><div class="line"></div><div class="line">filetype on  <span class="string">" 侦测文件类型</span></div><div class="line">syntax enable  <span class="string">" 开启语法高亮</span></div><div class="line">syntax on  <span class="string">" 使用Vim默认的语法高亮配色</span></div><div class="line"></div><div class="line">colorscheme desert  <span class="string">" 配色方案</span></div><div class="line"></div><div class="line">set fencs=utf-<span class="number">8</span>,gb18030,ucs-bom,gbk,gb2312,cp936,big5,latin-<span class="number">1</span>  <span class="string">" Vim在读入文件时将按此顺序依次尝试解码</span></div><div class="line">set fenc=utf-<span class="number">8</span>  <span class="string">" 设置当前文件编码</span></div><div class="line">set enc=utf-<span class="number">8</span>  <span class="string">" 设置Vim内部编码格式</span></div><div class="line">set tenc=utf-<span class="number">8</span>  <span class="string">" 设置当前Vim终端的编码格式</span></div><div class="line">set nobomb  <span class="string">" 禁止设置BOM</span></div><div class="line"></div><div class="line">set foldenable  <span class="string">" 开启折叠</span></div><div class="line">set foldmethod=syntax  <span class="string">" 根据语法规则创建可折叠区</span></div><div class="line">set foldcolumn=<span class="number">0</span>  <span class="string">" 禁用左侧折叠状态栏</span></div><div class="line">set foldlevel=<span class="number">3</span>  <span class="string">" 设置折叠层级为3，高于此层级的可折叠区将自动折叠</span></div><div class="line">set foldclose=all  <span class="string">" 设定所有高于foldlevel的可折叠区在光标移出后自动折叠</span></div><div class="line">nnoremap &lt;space&gt; @=((foldclosed(line('.'))&lt;<span class="number">0</span>)?'zc':'zo')&lt;CR&gt;  <span class="string">" 用空格键手动控制可折叠区的折叠与展开</span></div><div class="line">    <span class="string">" 上一条指令实际上是将空格键映射到一个判断并控制折叠的指令，具体解释如下：</span></div><div class="line">    <span class="string">"     nnoremap是无递归映射，即禁止右侧被映射到的指令继续映射，无递归映射可避免很多莫名其妙的bug</span></div><div class="line">    <span class="string">"     &lt;space&gt;是空格键，&lt;CR&gt;是回车</span></div><div class="line">    <span class="string">"     @=是表达式寄存器，其作用是执行右侧指令并得到计算结果，该结果必须是字符串</span></div><div class="line">    <span class="string">"     foldclosed()用于判断所指定的行是否被折叠，参数是行号，返回值是行号（被折叠）或-1（未被折叠）</span></div><div class="line">    <span class="string">"     line()用于获取指定行的行号，其参数'.'代表当前光标所在行</span></div><div class="line">    <span class="string">"     zc是折叠指令，zo是展开指令</span></div><div class="line">    <span class="string">"     实现功能就是按下空格时调用foldclosed()判断光标所在行是否处于展开状态，若是就调用zc折叠，若否则调用zo展开</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="string">" ================= gVim (Windows) 设置 ====================</span></div><div class="line"></div><div class="line"><span class="string">" 实际使用中最好将这部分设置放在 [Vim 通用设置] 之前以避免上述设置被覆盖</span></div><div class="line"></div><div class="line"><span class="string">" set guifont=Consolas:h12  "</span> 字体设置</div><div class="line"></div><div class="line"><span class="string">" source $VIMRUNTIME/vimrc_example.vim  "</span> 使用gVim附带的vimrc示例配置</div><div class="line"><span class="string">" source $VIMRUNTIME/mswin.vim  "</span> 使用gVim附带的Windows风格的快捷键映射</div><div class="line"><span class="string">" behave mswin  "</span> 设定鼠标选择行为采用Windows风格</div><div class="line"></div><div class="line"><span class="string">" if has("</span>win32<span class="string">")   "</span> 设置Vim启动时自动最大化</div><div class="line"><span class="string">"   au GUIEnter * simalt ~x</span></div><div class="line"><span class="string">" endif</span></div><div class="line"></div><div class="line"><span class="string">" source $VIMRUNTIME/delmenu.vim  "</span> 使用gVim附带的.vim文件删除所有菜单设定</div><div class="line"><span class="string">" source $VIMRUNTIME/menu.vim  "</span> 按照gVim附带的.vim文件重新设定菜单</div><div class="line"><span class="string">" language messages zh_CN.utf-8  "</span> 设定使用utf-<span class="number">8</span>编码的简体中文显示信息</div></pre></td></tr></table></figure>

<p>如果对上述指令不明白，可利用<code>:help</code>指令查询Vim帮助文档，如<code>:help &#39;autoindent&#39;</code>。</p>
<h2 id="相关资料">相关资料</h2>
<h3 id="Vim教程">Vim教程</h3>
<ul>
<li>vimtutor（Vim自带教程）</li>
<li><a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">Learn Vim Progressively</a>（英文版）、<a href="http://www.ccvita.com/487.html" target="_blank" rel="external">《简明Vim练级攻略》</a>（中文版） </li>
<li><a href="http://files.swaroopch.com/vim/byte_of_vim_v051.pdf" target="_blank" rel="external">A Byte of Vim</a></li>
<li><a href="http://www.openvim.com/" target="_blank" rel="external">Interactive Vim tutorial</a></li>
<li><a href="http://www.study-area.org/tips/vim/index.html" target="_blank" rel="external">大家來學VIM（一個歷久彌新的編輯器）</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0310vi.php" target="_blank" rel="external">vim程式編輯器</a></li>
</ul>
<h3 id="Vim技巧">Vim技巧</h3>
<ul>
<li><a href="http://www.2maomao.com/blog/wp-content/uploads/vim_tips.txt" target="_blank" rel="external">最佳vim技巧</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-tip-prompt/tip15/" target="_blank" rel="external">神奇的VIM</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?type_by=%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0&amp;view_by=search&amp;search_by=Vim+%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF" target="_blank" rel="external">Vim 实用技术</a></li>
<li><a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/" target="_blank" rel="external">vi/vim使用进阶</a></li>
</ul>
<h3 id="Vim配置-1">Vim配置</h3>
<ul>
<li><a href="http://amix.dk/vim/vimrc.html" target="_blank" rel="external">The ultimate Vim configuration</a>（amix.dk原版）、<a href="http://blog.csdn.net/redguardtoo/article/details/1172136" target="_blank" rel="external">《史上最强的Vim 配置文件》</a>（国内网友修订版）</li>
<li><a href="http://vimconfig.com/" target="_blank" rel="external">VimConfig</a> </li>
</ul>
<h3 id="Vim游戏">Vim游戏</h3>
<ul>
<li><a href="http://vim-adventures.com/" target="_blank" rel="external">VIM Adventures</a></li>
<li><a href="http://vimgolf.com/" target="_blank" rel="external">VimGolf</a> </li>
</ul>
<h3 id="正则表达式">正则表达式</h3>
<ul>
<li>Vim帮助文档中关于正则表达式的说明<code>:help regex</code></li>
<li><a href="http://vimregex.com/" target="_blank" rel="external">Vim Regular Expressions 101</a></li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">正则表达式语法</a></li>
<li><a href="http://www.regexr.com/" target="_blank" rel="external">RegExr</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Vim的模式">Vim的模式</h2>
<p>按照帮助文档（<code>:help vim-modes</code>）的说法，Vim共有12种模式，包括6种基本模式和6种派生模式；作为初学者，至少要掌握其中5种模式：普通模式（Normal）、插入模式（Insert）、改写模式（Replace）、命令行模式（Cmdline）和可视模式（Visual）。充分了解这5种模式的区别并熟练掌握这些模式间的转换应当是每一位Vim使用者的基本功：<br>]]>
    
    </summary>
    
      <category term="Vim" scheme="http://sunxb10.github.io/tags/Vim/"/>
    
      <category term="Vim" scheme="http://sunxb10.github.io/categories/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Hexo中显示数学公式]]></title>
    <link href="http://sunxb10.github.io/2015/01/02/display-math-equations-with-hexo/"/>
    <id>http://sunxb10.github.io/2015/01/02/display-math-equations-with-hexo/</id>
    <published>2015-01-02T15:58:05.000Z</published>
    <updated>2015-03-19T12:23:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="MathJax配置">MathJax配置</h2>
<p>为显示数学公式，首先需配置<a href="http://www.mathjax.org/" target="_blank" rel="external">MathJax</a>，这是用于渲染和显示数学公式的JavaScript库，能将用户输入的<a href="http://en.wikipedia.org/wiki/LaTeX" target="_blank" rel="external">$\mathrm{\LaTeX}$</a>、<a href="http://en.wikipedia.org/wiki/MathML" target="_blank" rel="external">MathML</a>和<a href="http://en.wikipedia.org/wiki/ASCIIMathML" target="_blank" rel="external">ASCIIMathML</a>指令转换为可在浏览器中显示的数学公式，并且它所渲染输出的数学公式是真正的矢量字符，而不是像维基百科等网站那样使用点阵图片显示公式和符号。</p>
<a id="more"></a>
<p>考虑到MathML和ASCIIMathML指令较为繁杂，这里只配置针对$\mathrm{\LaTeX}$指令的渲染。在Hexo博客目录中找到文件<code>/themes/xxxx/layout/_partial/head.ejs</code>（<code>xxxx</code>代表当前使用的主题），在<code>&lt;head&gt;...&lt;/head&gt;</code>标签内帖入如下代码：</p>
<figure class="highlight html"><figcaption><span>MathJax configuration</span><a href="https://gist.github.com/sunxb10/b410f82fb8bc07e1b76d" target="_blank" rel="external">gist snippet</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- MathJax Start --&gt;</span></div><div class="line"><span class="comment">&lt;!-- MathJax documentation: http://docs.mathjax.org/en/latest/index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript"></span></div><div class="line">  MathJax.Hub.Config({</div><div class="line">    tex2jax: {  <span class="comment">// tex2jax preprocessor</span></div><div class="line">      inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>] ],  <span class="comment">// delimiters for in-line math</span></div><div class="line">      displayMath: [ [<span class="string">'$$'</span>,<span class="string">'$$'</span>] ],  <span class="comment">// delimiters for displayed equations</span></div><div class="line">      processEscapes: <span class="literal">true</span>,  <span class="comment">// enable \$ to represent a single dollar sign</span></div><div class="line">      skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>, <span class="string">'code'</span>]  <span class="comment">// MathJax will not process contents inside these tags </span></div><div class="line">    },</div><div class="line">    TeX: {  <span class="comment">// TeX/LaTeX input processor</span></div><div class="line">      equationNumbers: { autoNumber: <span class="string">"AMS"</span> },  <span class="comment">// only number those equations in specific AMSmath environments</span></div><div class="line">      extensions: [<span class="string">"AMSmath.js"</span>,<span class="string">"AMSsymbols.js"</span>,<span class="string">"noErrors.js"</span>,<span class="string">"noUndefined.js"</span>]  <span class="comment">// introduce AMS extensions and suppress generating error messages </span></div><div class="line">    },</div><div class="line">    <span class="string">"HTML-CSS"</span>: {  <span class="comment">// HTML-CSS output processor (this is the default output of MathJax)</span></div><div class="line">      scale: <span class="number">110</span>,  <span class="comment">// The scaling factor of math with respect to the surrounding text</span></div><div class="line">      linebreaks: { automatic: <span class="literal">true</span> } <span class="comment">// automatically breaks the line if necessary</span></div><div class="line">    },</div><div class="line">    SVG: {  <span class="comment">// SVG output processor</span></div><div class="line">      scale: <span class="number">110</span>,  <span class="comment">// The scaling factor of math with respect to the surrounding text</span></div><div class="line">      linebreaks: { automatic: <span class="literal">true</span> } <span class="comment">// automatically breaks the line if necessary</span></div><div class="line">    },</div><div class="line">    menuSettings: {  <span class="comment">// settings for the mathematics contextual menu</span></div><div class="line">      zoom: <span class="string">"Hover"</span>  <span class="comment">// set equation zooming to be triggered by a single mouse click</span></div><div class="line">    }</div><div class="line">  });</div><div class="line"> </div><div class="line">  MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ <span class="comment">// Fix &lt;code&gt; tags after MathJax finishes running, this is a hack to overcome a shortcoming of Markdown</span></div><div class="line">      <span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;</div><div class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) {</div><div class="line">          all[i].SourceElement().parentNode.className += <span class="string">' has-jax'</span>;</div><div class="line">      }</div><div class="line">  });</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span></span></div><div class="line">   <span class="attribute">src</span>=<span class="value">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;<span class="javascript">  <span class="comment">// link to the MathJax CDN</span></span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- MathJax End --&gt;</span></div></pre></td></tr></table></figure>

<p>其中各项设置的具体作用可参见<a href="http://docs.mathjax.org/en/latest/" target="_blank" rel="external">官方文档</a>，用户也可根据需要自行修改，下面的示例都将基于上面的MathJax配置实现。</p>
<h2 id="行内公式与行间公式">行内公式与行间公式</h2>
<p>使用<code>$...$</code>输入行内公式（inline-style math）：</p>
<ul>
<li><p>输入：<code>$E = m c^{2}$</code></p>
<p>输出：$E = m c^{2}$</p>
</li>
<li><p>输入：<code>$a^{2} + b^{2} = c^{2}$</code></p>
<p>输出：$a^{2} + b^{2} = c^{2}$</p>
</li>
</ul>
<p>使用<code>$$...$$</code>输入行间公式（display-style math）：</p>
<ul>
<li><p>输入：<code>$$f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}$$</code></p>
<p>输出：$$f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}$$</p>
</li>
<li><p>输入：<code>$$v=\frac{\Delta s}{\Delta t}$$</code></p>
<p>输出：$$v=\frac{\Delta s}{\Delta t}$$</p>
</li>
</ul>
<h2 id="特殊符号与公式换行">特殊符号与公式换行</h2>
<p>若用户输入的$\mathrm{\LaTeX}$代码中包含Markdown的特殊符号（如<code>_</code>、<code>*</code>），则公式渲染会因Markdown解析而导致错误：</p>
<ul>
<li><p>输入：<code>$$f_{n}=f_{n-1}+f_{n-2}$$</code></p>
<p>输出：$$f<em>{n}=f</em>{n-1}+f_{n-2}$$</p>
</li>
</ul>
<p>解决办法是在这些特殊符号前加转义符号<code>\</code>以规避 Markdown 解析：</p>
<ul>
<li><p>输入：<code>$$f\_{n}=f\_{n-1}+f\_{n-2}$$</code></p>
<p>输出：$$f_{n}=f_{n-1}+f_{n-2}$$</p>
</li>
</ul>
<p>但<code>\</code>同时也是$\mathrm{\LaTeX}$的特殊符号，所以在多行公式换行时必须用<code>\\\</code>而不是<code>\\</code>：</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="formula">$$</span></div><div class="line"><span class="command">\mathrm</span><span class="special">{</span>e<span class="special">}</span>^<span class="special">{</span>i<span class="command">\theta</span><span class="special">}</span>=<span class="command">\cos</span><span class="command">\theta</span>+i<span class="command">\sin</span><span class="command">\theta</span><span class="command">\\</span></div><div class="line"><span class="command">\mathrm</span><span class="special">{</span>e<span class="special">}</span>^<span class="special">{</span>i<span class="command">\pi</span><span class="special">}</span>+1=0</div><div class="line">$$</div></pre></td></tr></table></figure>

<p>  输出：<br>  $$<br>  \mathrm{e}^{i\theta}=\cos\theta+i\sin\theta\<br>  \mathrm{e}^{i\pi}+1=0<br>  $$</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="formula">$$</span></div><div class="line"><span class="command">\mathrm</span><span class="special">{</span>e<span class="special">}</span>^<span class="special">{</span>i<span class="command">\theta</span><span class="special">}</span>=<span class="command">\cos</span><span class="command">\theta</span>+i<span class="command">\sin</span><span class="command">\theta</span><span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="command">\mathrm</span><span class="special">{</span>e<span class="special">}</span>^<span class="special">{</span>i<span class="command">\pi</span><span class="special">}</span>+1=0</div><div class="line">$$</div></pre></td></tr></table></figure>

<p>  输出：<br>  $$<br>  \mathrm{e}^{i\theta}=\cos\theta+i\sin\theta\\<br>  \mathrm{e}^{i\pi}+1=0<br>  $$</p>
<p>另外，由于<code>$</code>已被当做行内公式的定界符，如果需要输入单独的美元符号，应输入<code>\$</code>，即得到\$。</p>
<h2 id="数学环境">数学环境</h2>
<p>$\mathrm{\LaTeX}$提供了<code>equation</code>、<code>align</code>、<code>eqnarray</code>等用于排版复杂公式的数学环境，在Hexo中可以直接使用这些数学环境，不需要将其置于<code>$...$</code>或<code>$$...$$</code>之间，因此实际上可以用这些数学环境取代前面介绍的<code>$$...$$</code>行间公式：</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="command">\begin</span><span class="special">{</span>equation<span class="special">}</span></div><div class="line">f<span class="command">\_</span><span class="special">{</span>0<span class="special">}</span> = 1<span class="command">\\</span><span class="command">\</span></div><div class="line">f<span class="command">\_</span><span class="special">{</span>1<span class="special">}</span> = 1<span class="command">\\</span><span class="command">\</span></div><div class="line">f<span class="command">\_</span><span class="special">{</span>n<span class="special">}</span> = f<span class="command">\_</span><span class="special">{</span>n-1<span class="special">}</span> + f<span class="command">\_</span><span class="special">{</span>n-2<span class="special">}</span><span class="command">\quad</span> (n&gt;1)</div><div class="line"><span class="command">\end</span><span class="special">{</span>equation<span class="special">}</span></div></pre></td></tr></table></figure>

<p>  输出：<br>  \begin{equation}<br>  f_{0} = 1\\<br>  f_{1} = 1\\<br>  f_{n} = f_{n-1} + f_{n-2}\quad (n&gt;1)<br>  \end{equation}</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="command">\begin</span><span class="special">{</span>align<span class="special">}</span></div><div class="line"><span class="command">\begin</span><span class="special">{</span>vmatrix<span class="special">}</span></div><div class="line">1 <span class="special">&</span> 1 <span class="special">&</span> 1 <span class="special">&</span> <span class="command">\cdots</span> <span class="special">&</span> 1 <span class="command">\\</span><span class="command">\</span></div><div class="line">a<span class="command">\_</span><span class="special">{</span>1<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>2<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>3<span class="special">}</span> <span class="special">&</span> <span class="command">\cdots</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>n<span class="special">}</span> <span class="command">\\</span><span class="command">\</span></div><div class="line">a<span class="command">\_</span><span class="special">{</span>1<span class="special">}</span>^<span class="special">{</span>2<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>2<span class="special">}</span>^<span class="special">{</span>2<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>3<span class="special">}</span>^<span class="special">{</span>2<span class="special">}</span> <span class="special">&</span> <span class="command">\cdots</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>n<span class="special">}</span>^<span class="special">{</span>2<span class="special">}</span> <span class="command">\\</span><span class="command">\</span></div><div class="line">a<span class="command">\_</span><span class="special">{</span>1<span class="special">}</span>^<span class="special">{</span>3<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>2<span class="special">}</span>^<span class="special">{</span>3<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>3<span class="special">}</span>^<span class="special">{</span>3<span class="special">}</span> <span class="special">&</span> <span class="command">\cdots</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>n<span class="special">}</span>^<span class="special">{</span>3<span class="special">}</span> <span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="command">\vdots</span> <span class="special">&</span> <span class="command">\vdots</span> <span class="special">&</span> <span class="command">\vdots</span> <span class="special">&</span> <span class="command">\ddots</span> <span class="special">&</span> <span class="command">\vdots</span> <span class="command">\\</span><span class="command">\</span></div><div class="line">a<span class="command">\_</span><span class="special">{</span>1<span class="special">}</span>^<span class="special">{</span>n−1<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>2<span class="special">}</span>^<span class="special">{</span>n−1<span class="special">}</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>3<span class="special">}</span>^<span class="special">{</span>n−1<span class="special">}</span> <span class="special">&</span> <span class="command">\cdots</span> <span class="special">&</span> a<span class="command">\_</span><span class="special">{</span>n<span class="special">}</span>^<span class="special">{</span>n−1<span class="special">}</span></div><div class="line"><span class="command">\end</span><span class="special">{</span>vmatrix<span class="special">}</span> = <span class="command">\prod</span><span class="command">\_</span><span class="special">{</span>1<span class="command">\leqslant</span><span class="special">{</span><span class="special">}</span>j &lt; i<span class="command">\leqslant</span><span class="special">{</span><span class="special">}</span>n<span class="special">}</span>(a<span class="command">\_</span><span class="special">{</span>i<span class="special">}</span>−a<span class="command">\_</span><span class="special">{</span>j<span class="special">}</span>) </div><div class="line"><span class="command">\end</span><span class="special">{</span>align<span class="special">}</span></div></pre></td></tr></table></figure>

<p>  输出：<br>  \begin{align}<br>  \begin{vmatrix}<br>  1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\<br>  a_{1} &amp; a_{2} &amp; a_{3} &amp; \cdots &amp; a_{n} \\<br>  a_{1}^{2} &amp; a_{2}^{2} &amp; a_{3}^{2} &amp; \cdots &amp; a_{n}^{2} \\<br>  a_{1}^{3} &amp; a_{2}^{3} &amp; a_{3}^{3} &amp; \cdots &amp; a_{n}^{3} \\<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>  a_{1}^{n−1} &amp; a_{2}^{n−1} &amp; a_{3}^{n−1} &amp; \cdots &amp; a_{n}^{n−1}<br>  \end{vmatrix} = \prod_{1\leqslant{}j &lt; i\leqslant{}n}(a_{i}−a_{j})<br>  \end{align}</p>
<h2 id="公式引用">公式引用</h2>
<p>通过MathJax还可以实现$\mathrm{\LaTeX}$引用公式编号的功能：</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="command">\begin</span><span class="special">{</span>align<span class="special">}</span></div><div class="line"><span class="special">&</span>e^<span class="special">{</span>i<span class="command">\pi</span><span class="special">}</span> + 1 = 0 <span class="command">\label</span><span class="special">{</span>eq:Euler<span class="special">}</span><span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="special">&</span><span class="command">\hat</span><span class="special">{</span>H<span class="special">}</span><span class="command">\Psi</span> = i<span class="command">\hbar</span><span class="command">\frac</span><span class="special">{</span><span class="command">\partial</span><span class="special">}</span><span class="special">{</span><span class="command">\partial</span> t<span class="special">}</span><span class="command">\Psi</span> <span class="command">\label</span><span class="special">{</span>eq:Schrödinger<span class="special">}</span><span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="special">&</span><span class="command">\sqrt</span><span class="special">{</span>1 + 2<span class="command">\sqrt</span><span class="special">{</span>1 + 3<span class="command">\sqrt</span><span class="special">{</span>1 + 4<span class="command">\sqrt</span><span class="special">{</span>1 + <span class="command">\cdots</span><span class="special">}</span><span class="special">}</span><span class="special">}</span><span class="special">}</span> = 3 <span class="command">\label</span><span class="special">{</span>eq:Ramanujan<span class="special">}</span></div><div class="line"><span class="command">\end</span><span class="special">{</span>align<span class="special">}</span></div></pre></td></tr></table></figure>

<p>  输出：<br>  \begin{align}<br>  &amp;e^{i\pi} + 1 = 0 \label{eq:Euler}\\<br>  &amp;\hat{H}\Psi = i\hbar\frac{\partial}{\partial t}\Psi \label{eq:Schrödinger}\\<br>  &amp;\sqrt{1 + 2\sqrt{1 + 3\sqrt{1 + 4\sqrt{1 + \cdots}}}} = 3 \label{eq:Ramanujan}<br>  \end{align}</p>
<p>使用<code>\eqref{}</code>即可对带有<code>\label{}</code>的公式进行引用：</p>
<ol>
<li><p>输入：<code>\eqref{eq:Euler}式是欧拉公式</code></p>
<p>输出：\eqref{eq:Euler}式是欧拉公式</p>
</li>
<li><p>输入：<code>\eqref{eq:Schrödinger}式是薛定谔方程</code></p>
<p>输出：\eqref{eq:Schrödinger}式是薛定谔方程</p>
</li>
<li><p>输入：<code>\eqref{eq:Ramanujan}式是拉马努金恒等式</code></p>
<p>输出：\eqref{eq:Ramanujan}式是拉马努金恒等式</p>
</li>
</ol>
<h2 id="公式编号">公式编号</h2>
<p><code>equation</code>、<code>align</code>和<code>eqnarray</code>环境会为公式自动编号，对应地，$\mathrm{\LaTeX}$也分别提供了不带编号的<code>equation*</code>、<code>align*</code>和<code>eqnarray*</code>环境。但这里不能直接使用这三个不带编号的环境，原因就是这些环境的名称中出现了Markdown的特殊符号<code>*</code>，不难想见解决办法就是在环境名称的<code>*</code>前面加<code>\</code>：</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="command">\begin</span><span class="special">{</span>align<span class="command">\*</span><span class="special">}</span></div><div class="line"><span class="special">&</span><span class="command">\nabla</span> <span class="command">\cdot</span> <span class="command">\boldsymbol</span><span class="special">{</span>E<span class="special">}</span> = <span class="command">\frac</span><span class="special">{</span><span class="command">\rho</span><span class="special">}</span><span class="special">{</span><span class="command">\varepsilon</span><span class="command">\_</span><span class="special">{</span>0<span class="special">}</span><span class="special">}</span> <span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="special">&</span><span class="command">\nabla</span> <span class="command">\cdot</span> <span class="command">\boldsymbol</span><span class="special">{</span>B<span class="special">}</span> = 0 <span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="special">&</span><span class="command">\nabla</span> <span class="command">\times</span> <span class="command">\boldsymbol</span><span class="special">{</span>E<span class="special">}</span> = -<span class="command">\frac</span><span class="special">{</span><span class="command">\partial</span><span class="command">\boldsymbol</span><span class="special">{</span>B<span class="special">}</span><span class="special">}</span><span class="special">{</span><span class="command">\partial</span> t<span class="special">}</span> <span class="command">\\</span><span class="command">\</span></div><div class="line"><span class="special">&</span><span class="command">\nabla</span> <span class="command">\times</span> <span class="command">\boldsymbol</span><span class="special">{</span>B<span class="special">}</span> = <span class="command">\mu</span><span class="command">\_</span><span class="special">{</span>0<span class="special">}</span> <span class="command">\boldsymbol</span><span class="special">{</span>J<span class="special">}</span> + <span class="command">\mu</span><span class="command">\_</span><span class="special">{</span>0<span class="special">}</span><span class="command">\varepsilon</span><span class="command">\_</span><span class="special">{</span>0<span class="special">}</span><span class="command">\frac</span><span class="special">{</span><span class="command">\partial</span><span class="command">\boldsymbol</span><span class="special">{</span>E<span class="special">}</span><span class="special">}</span><span class="special">{</span><span class="command">\partial</span> t<span class="special">}</span></div><div class="line"><span class="command">\end</span><span class="special">{</span>align<span class="command">\*</span><span class="special">}</span></div></pre></td></tr></table></figure>

<p>  输出：<br>  \begin{align*}<br>  &amp;\nabla \cdot \boldsymbol{E} = \frac{\rho}{\varepsilon_{0}} \\<br>  &amp;\nabla \cdot \boldsymbol{B} = 0 \\<br>  &amp;\nabla \times \boldsymbol{E} = -\frac{\partial\boldsymbol{B}}{\partial t} \\<br>  &amp;\nabla \times \boldsymbol{B} = \mu_{0} \boldsymbol{J} + \mu_{0}\varepsilon_{0}\frac{\partial\boldsymbol{E}}{\partial t}<br>  \end{align*}</p>
<p>如果在同一个数学环境中需要给其中一部分公式编号，而另一部分公式不编号，则可以使用自动编号的<code>equation</code>、<code>align</code>和<code>eqnarray</code>环境，然后在不需要编号的公式之后（换行符<code>\\\</code>之前）加上指令<code>\notag</code>：</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="command">\begin</span><span class="special">{</span>align<span class="special">}</span></div><div class="line">E <span class="special">&</span>= mc^<span class="special">{</span>2<span class="special">}</span> <span class="command">\notag</span> <span class="command">\\</span><span class="command">\</span></div><div class="line">E <span class="special">&</span>= h<span class="command">\nu</span> <span class="command">\notag</span> <span class="command">\\</span><span class="command">\</span></div><div class="line">m <span class="special">&</span>= h<span class="command">\nu</span>/c^<span class="special">{</span>2<span class="special">}</span></div><div class="line"><span class="command">\end</span><span class="special">{</span>align<span class="special">}</span></div></pre></td></tr></table></figure>

<p>  输出：<br>  \begin{align}<br>  E &amp;= mc^{2} \notag \\<br>  E &amp;= h\nu \notag \\<br>  m &amp;= h\nu/c^{2}<br>  \end{align}</p>
<h2 id="将公式复制到本地文件">将公式复制到本地文件</h2>
<p>在MathJax渲染得到的公式上单击鼠标右键弹出菜单，点击<code>Show Math As</code>子菜单中的<code>MathML Code</code>，将得到的MathML代码复制粘贴到本地的Microsoft Word文档中，并把粘贴选项改为“只保留文本”，如此即可得到相应公式，还可以用Microsoft Word自带的公式编辑器做进一步修改。该操作貌似只适用于Microsoft Word 2007之后的版本（即支持<code>.docx</code>格式的版本）。</p>
<p>同理，在上述<code>Show Math As</code>的子菜单中选择<code>TeX Commands</code>即可得到相应的$\mathrm{\TeX}$代码。</p>
<h2 id="备注">备注</h2>
<p>本博客当前使用的<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a>主题已包含MathJax，具体配置在<code>/themes/jacman/layout/_partial/mathjax.ejs</code>文件中，用户可根据需求对其进行修改。若某篇文章需要使用MathJax显示数学公式，则用户只需在相应Markdown文件头部的front-matter内注明<code>mathjax: true</code>即可。</p>
<p>MathJax库与Markdown解析器之间的相容配合是实现数学公式显示的关键，考虑到Markdown有多种实现和解析器，再加上MathJax库和Markdown解析器自身的升级迭代，上面介绍的这套方法有可能在特定情况下出现某些bug，请诸位谅解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="MathJax配置">MathJax配置</h2>
<p>为显示数学公式，首先需配置<a href="http://www.mathjax.org/" target="_blank" rel="external">MathJax</a>，这是用于渲染和显示数学公式的JavaScript库，能将用户输入的<a href="http://en.wikipedia.org/wiki/LaTeX" target="_blank" rel="external">$\mathrm{\LaTeX}$</a>、<a href="http://en.wikipedia.org/wiki/MathML" target="_blank" rel="external">MathML</a>和<a href="http://en.wikipedia.org/wiki/ASCIIMathML" target="_blank" rel="external">ASCIIMathML</a>指令转换为可在浏览器中显示的数学公式，并且它所渲染输出的数学公式是真正的矢量字符，而不是像维基百科等网站那样使用点阵图片显示公式和符号。</p>
]]>
    
    </summary>
    
      <category term="数学" scheme="http://sunxb10.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Hexo" scheme="http://sunxb10.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://sunxb10.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RSA加密算法学习笔记]]></title>
    <link href="http://sunxb10.github.io/2015/01/02/notes-on-rsa/"/>
    <id>http://sunxb10.github.io/2015/01/02/notes-on-rsa/</id>
    <published>2015-01-02T14:46:52.000Z</published>
    <updated>2015-03-20T06:39:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="历史">历史</h2>
<p>自<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E6%A3%92" target="_blank" rel="external">密码棒</a>和<a href="http://zh.wikipedia.org/wiki/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81" target="_blank" rel="external">凯撒密码</a>发明之后，人们在漫长的历史岁月中始终遵循着一套相同的加密、解密模式，即Alice使用一个<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5" target="_blank" rel="external">密钥</a>对<a href="http://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87" target="_blank" rel="external">明文</a>进行加密得到<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87" target="_blank" rel="external">密文</a>，Bob收到密文后使用同样的密钥进行解密得到明文。其中加密和解密使用的是同一个密钥，这种模式称为“<a href="http://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="external">对称密码系统</a>”。显然，对称密码系统很容易理解，从技术层面上来讲也比较容易实现，但这种系统存在一个极为棘手的问题，即如何安全地保存和传递密钥，毕竟保存和传递本身也有可能被攻击或窃听。</p>
<a id="more"></a>
<p>1974年，正在UC Berkeley读本科的Ralph Merkle在一次讨论课上提出了一种被称作<a href="http://en.wikipedia.org/wiki/Ralph_Merkle_puzzle_cryptographic_system" target="_blank" rel="external">Merkle’s Puzzles</a>（Merkle难题）的密码系统，其基本思路是Bob首先向Alice发去大量的难题，其中每一个难题本身都可以用蛮力算法在有限的时间内破解，得到的答案就是一个可用的密钥；Alice收到难题后随机选取一道进行破解，之后采用得到的密钥对一段双方事先约定好的信息进行加密（这段信息无需保密，甚至也不需要事先约定，可以在通讯开始之前先用明文直接发过去，之后再解题和加密），并将密文发给Bob；由于所有的难题都是Bob编制的，因此他应当知道所有谜题的答案（即所有可能的密钥），Bob收到密文后只需要用这些密钥一一尝试解密即可，如此操作即可保证Alice和Bob得到相同的密钥。而窃听者Eve即便可以窃听到Alice和Bob之间所有的通讯也无法完成解密，由于她不知道Alice破解的是哪一条谜题，故只能尝试破解掉所有的谜题；如果谜题数量足够大，则Eve在足够长的时间内都不可能获得真正的密钥（此处还要求Eve在知道明文和密文的情况下不能反推出密钥）。可以看出Merkle难题不同于以往的对称密码系统，在整个过程中并不需要显式地传递双方真正使用的密钥。当然，发送“大量难题”本身并不十分现实，这会受到网络带宽、传输速度、储存容量等实际因素的制约；不过，Merkle难题仍旧具有十分重要的意义，可以说它是<a href="http://zh.wikipedia.org/wiki/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">非对称密码系统</a>（即公钥密码系统）的雏形。</p>
<p>1976年，Whitfield Diffie和Martin Hellman提出了<a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="external">Diffie–Hellman key exchange</a>（Diffie–Hellman密钥交换协议），这标志着非对称密码系统的正式诞生。Diffie–Hellman密钥交换协议的主要思想是借助<a href="http://en.wikipedia.org/wiki/Trapdoor_function" target="_blank" rel="external">trapdoor function</a>（暗门函数）产生公钥和私钥，这类函数的特点是按一个方向运算很容易，但反过来做运算则十分困难，最经典的暗门函数就是大数的分解质因数：给定两个<a href="http://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0" target="_blank" rel="external">质数</a>（即素数），计算它们的乘积很容易；但给定一个很大的<a href="http://zh.wikipedia.org/wiki/%E5%90%88%E6%95%B0" target="_blank" rel="external">合数</a>，要求将其分解为素数的乘积却十分困难。因此，Bob可以用一个非常大的合数作为公钥，并将其公之于众，所有想给Bob发信息的人（如Alice）都应使用此公钥进行加密；Bob以该合数的其中一个质因数为私钥，在其收到密文后使用该私钥解密（当然，这里还需要有一系列经过巧妙设计的算法以实现非对称的加密和解密）。对于Bob而言，他可以先选定两个素数，再计算其乘积作为公钥；但对于攻击者而言，在只知道乘积（合数，即公钥）的情况下想反过来得到质因数（即私钥）却十分困难。作为一个形象的比喻，非对称密码系统相当于小区里家门口的信箱，任何人都可以通过箱口（公钥）向里面投入信件，但只有户主能用自己的钥匙（私钥）打开信箱获取信息。</p>
<p>1977年，日后风靡世界的RSA加密算法终于横空出世，其发明者是当时在MIT工作的三位密码学大牛Ron Rivest、Adi Shamir和Leonard Adleman，“RSA”这个名称实际上就来自于三人姓氏的首字母（必须说明的是，就职于英国政府通信总局的数学家Clifford Cocks曾在1973年的一篇内部文章中提及同样的算法，但他的这一发现被列为政府机密，直到1997年才得以公开发表）。经历数十年的发展，RSA已经成为应用最广泛的非对称密码系统。截止到目前（2014年），人们所能破解的RSA加密系统的最长公钥位数为768位（<a href="http://en.wikipedia.org/wiki/RSA-768#RSA-768" target="_blank" rel="external">RSA-768</a>，2009年12月破解），而实际使用的RSA公钥长度通常为1024位或2048位（这里的“位数”均代表二进制位）。</p>
<p>下面就是对于RSA算法的详细介绍：</p>
<h2 id="预备知识（基础数论）">预备知识（基础数论）</h2>
<p>对于正整数$N$，定义集合$Z_{N}=\lbrace0,1,2,\dots,N-1\rbrace$，同时定义集合上的两种运算：模加、模乘，这两种运算与普通的加法、乘法类似，只是多了一步取模$N$而已，例如在$Z_{12}$上有运算<br>$$<br>9+8=5\,(\mathrm{mod}\,12)\\<br>5\times7=11\,(\mathrm{mod}\,12)<br>$$<br>从抽象代数的角度来看，这样定义的集合$Z_{N}$及模加、模乘运算构成了一个<a href="http://zh.wikipedia.org/wiki/%E7%8E%AF_(%E4%BB%A3%E6%95%B0)" target="_blank" rel="external">环</a>。对于$Z_{N}$中的元素$a$而言，如果存在元素$b\in{}Z_{N}$使得$\,a\cdot{}b=1\,(\mathrm{mod}\,N)$，则称$a$和$b$互为对方的逆或<a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0" target="_blank" rel="external">模反元素</a>，同时称二者在$Z_{N}$中均为可逆元素。严格的数学推导可以证明，对于给定集合$Z_{N}$，其中的某元素是可逆元素，当且仅当该元素与$N$<a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA" target="_blank" rel="external">互质</a>。比如$Z_{12}$中只有$\lbrace1,5,7,11\rbrace$才是可逆元素；假定$p$为质数，则$Z_{p}$中所有非零元素均可逆。</p>
<p>对于$Z_{N}$，我们选取其所有可逆的元素组成子集合$Z_{N}^{\ast}$。关于$Z_{N}^{\ast}$有几条非常重要的内容，首先是<a href="http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="external">费马（Fermat）小定理</a>：设$p$为素数，则有<br>$$<br>\forall{}x\in{}Z_{p}^{\ast},\ \ x^{p-1}=1\,(\mathrm{mod}\,p)\ \textrm{,}\ x^{p}=x\,(\mathrm{mod}\,p)<br>$$</p>
<p>其次是<a href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%95%86%E6%95%B0" target="_blank" rel="external">欧拉$\phi$函数</a>（或称为欧拉商数）。对于正整数$n$，定义其欧拉$\phi$函数为$\phi(n)=\vert Z_{N}^{\ast}\vert$，换言之，$\phi(n)$就是不大于$n$且与$n$互质的正整数的数目，譬如$\phi(12)=4$。显而易见如果$p$是素数，则$\phi(p)=p-1$。假设合数$N$可分解为两个素数$p$和$q$相乘（$N=pq$），则可证明$\phi(N)=N-p-q+1=(p-1)(q-1)$。</p>
<p>最后是<a href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)" target="_blank" rel="external">欧拉（Euler）定理</a>：<br>$$<br>\forall{}x\in{}Z_{N}^{\ast},\ \ x^{\phi(N)}=1\,(\mathrm{mod}\,N)<br>$$<br>可以看出欧拉定理实际上是费马小定理的推广形式，欧拉定理并不要求$N$为素数，而只要$x$与$N$互质即可。欧拉定理非常重要，事实上这就是整个RSA加密算法的核心。</p>
<h2 id="具体算法流程">具体算法流程</h2>
<ol>
<li>接收方选取两个足够大的相异素数$p$、$q$，计算乘积$N=pq$，同时得到$\phi(N)=(p-1)(q-1)$</li>
<li>接收方选取正整数$e$、$d$使$e\cdot{}d=1\,(\mathrm{mod}\,\phi(N))$（$e$被称作“加密指数”，$d$被称作“解密指数”）</li>
<li>接收方公布公钥$pk=(N,e)$，保留私钥$sk=(N,d)$，销毁$p$、$q$和$\phi(N)$</li>
<li>发送方使用公钥$pk$对明文$m$进行加密：$c=m^{e}\,(\mathrm{mod}\,N)$（明文$m$必须是小于$N$的整数；如果明文是字符串，则应当先将其转换为<a href="http://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">Unicode编码</a>或<a href="http://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII编码</a>）</li>
<li>接收方使用私钥$sk$对密文$c$进行解密：$c^{d}=m^{ed}=m\,(\mathrm{mod}\,N)$</li>
</ol>
<p>以上就是RSA加密和解密的算法，其中最后一步$m^{ed}=m\,(\mathrm{mod}\,N)$等式的成立性需要分两种情况说明：</p>
<ul>
<li>$m$与$N$互质：由欧拉定理直接得到$m^{ed}=m^{k\phi(N)+1}=(m^{\phi(N)})^{k}\cdot{}m=m\,(\mathrm{mod}\,N)$。</li>
<li>$m$不与$N$互质：$m^{ed}=m^{k\phi(N)+1}=m\cdot m^{k\phi(N)}=m\cdot (m^{p-1})^{k(q-1)}$，欧拉定理表明$m^{p-1}=1\,(\mathrm{mod}\,p)$，根据模运算的基本性质可得$m\cdot (m^{p-1})^{k(q-1)}=m\,(\mathrm{mod}\,p)$，即$m^{ed}=m\,(\mathrm{mod}\,p)$，同理可得$m^{ed}=m\,(\mathrm{mod}\,q)$。由于$p$和$q$是相异的素数，故必有$m^{ed}=m\,(\mathrm{mod}\,N)$。</li>
</ul>
<p>另外，在第2步生成$(e,d)$时，具体做法是先人为指定$e$（通常推荐65537），然后再利用<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="external">扩展欧几里得算法</a>计算$d$。扩展欧几里得算法的时间复杂度为$O(\log^{2}\phi(N))$（当$N$足够大时，$\phi(N)\approx{}N$），源代码如下（Python 3）：</p>
<figure class="highlight python3"><figcaption><span>extended Euclidean algorithm</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Extend_Euclid</span><span class="params">(e, phi)</span>:</span></div><div class="line">    <span class="keyword">if</span> phi == <span class="number">0</span>: </div><div class="line">        <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        (x, y) = Extend_Euclid(phi, e % phi)</div><div class="line">        (x, y) = (y, (x - (e / phi) * y))</div><div class="line">        <span class="keyword">return</span> (x, y)</div></pre></td></tr></table></figure>

<p>返回值<code>(x, y)</code>应当使<code>x * e + y * phi == 1</code>表达式结果为<code>True</code>，其中<code>x</code>就是我们需要的$d$。在实际编程时需要考虑到RSA密钥较长，直接使用Python内置的int类型会导致程序性能低下，推荐使用<a href="https://pypi.python.org/pypi/gmpy2" target="_blank" rel="external">gmpy2</a>库来处理。</p>
<h2 id="注意事项">注意事项</h2>
<p>上面所介绍的RSA算法<strong>不能</strong>直接用于加密实际信息，很多教材和资料往往忽视了这一点。严格来讲，此处介绍的RSA算法并不符合<a href="http://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8" target="_blank" rel="external">语义安全</a>的要求，因为该算法的每个步骤完全是确定性的，不包含任何随机性成分。针对直接使用RSA算法加密的信息，窃听者可以通过<a href="http://en.wikipedia.org/wiki/Meet-in-the-middle_attack" target="_blank" rel="external">meet-in-the-middle attack</a>大幅降低破解密码所需的时间：假定直接采用RSA加密明文$m$，同时假定$m$长度为64位。统计表明在大约20%的情况下，64位的明文$m$可分解为$m=m_{1}\cdot{}m_{2}$，且$m_{1},m_{2}&lt;2^{34}$，则密文为$c=m^{e}=m_{1}^{e}\cdot{}m_{2}^{e}\,(\mathrm{mod}\,N)$，同时有$c/m_{1}^{e}=m_{2}^{e}\,(\mathrm{mod}\,N)$。窃听者在得知密文$c$的情况下针对$m_{1}$所有可取的值逐一计算并记录$c/m_{1}^{e}$（即$\lbrace{}c/1^{e},c/2^{e},c/3^{e},\dots,c/2^{34e}\rbrace$），然后遍历检查$m_{2}$所有可取的值（即$\lbrace{}1,2,\dots,2^{34}\rbrace$），如果遇到$c/m_{1}^{e}=m_{2}^{e}\,(\mathrm{mod}\,N)$，则窃听者找到了匹配的$(m_{1},m_{2})$并可得到明文$m=m_{1}\cdot{}m_{2}$。考虑时间复杂度，创建表格需要$2^{34}$，之后查找也需要$2^{34}$（假定窃听者有足够的空间可以建立hash散列表），则窃听者破解密码的总时间为$2^{35}$，远远小于蛮力穷举$m$所需要的$2^{64}$，因而可以认为窃听者找到了有效的破解手段，相应的加密方法不安全。</p>
<p>RSA加密的ISO标准中规定RSA算法应当与能够校验信息的对称加密系统配合使用，具体来说就是发送方首先从RSA的$Z_{N}$中选取一个随机数，对其使用hash函数（<a href="http://en.wikipedia.org/wiki/SHA-256" target="_blank" rel="external">SHA-256</a>）得到对称加密系统所需的密钥，同时使用RSA算法对该随机数进行加密，将这两个加密结果一并发送；接收方收到密文后首先使用RSA的私钥解密得到发送方选取的随机数，再通过hash函数得到对称加密系统的密钥，最终解密得到明文。</p>
<p>在实际使用中，包含RSA算法的加密系统一般会采用<a href="http://en.wikipedia.org/wiki/PKCS_1" target="_blank" rel="external">PKCS1标准</a>，该标准与ISO标准略有不同：发送方首先生成一个密钥并使用对称加密系统进行加密，之后按照PKCS1标准对密钥做一定处理并采用RSA算法对其加密，然后将两个加密结果一并发送；接收方收到密文后，首先采用RSA算法解密，之后按照PKCS1标准逆处理得到密钥，最后使用对称加密系统解密得到明文。其中关键在于使用RSA加密前如何处理对称加密系统的密钥，该步骤称为“预处理（preprocessing）”，不同版本的PKCS1标准规定也不同，总体思路都是将较短的密钥扩展为足够长的二进制串，比如PKCS1 v1.5的规定是将对称加密系统的密钥（128位或256位）与一定长度的随机数串和特定位置上的标识符（如“00”、“FF”等）首尾相连构成2048位的二进制串，然后再交由RSA算法加密；PKCS1 v2.0则更加复杂，其中使用了hash函数（SHA-256）以及<a href="http://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96" target="_blank" rel="external">异或</a>（xor）运算等，同时也包含随机数串和标识符等。</p>
<p>另外，使用RSA加密算法时还需要注意不能使$p$和$q$过于接近，否则攻击者可以从$\sqrt{N}$出发进行遍历搜索，经过不长时间即可确定$p$和$q$从而破解RSA加密，下面就是一个反例：</p>
<figure class="highlight python3"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">N </span>=<span class="string"> 648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877</span></div></pre></td></tr></table></figure>

<p>这里的<code>N</code>非常大，换算为二进制后长度为1026位，已经超过了RSA-768，达到实用 RSA 加密系统的长度；但其质因数<code>p</code>和<code>q</code>过于接近，因而攻击者可以在非常短的时间内找出这两个质因数：</p>
<figure class="highlight python3"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">p =</span> <span class="number">25464796146996183438008816563973942229341454268524157846328581927885777970106398054491246526970814167632563509541784734741871379856682354747718346471375403</span></div><div class="line"></div><div class="line"><span class="variable">q =</span> <span class="number">25464796146996183438008816563973942229341454268524157846328581927885777969985222835143851073249573454107384461557193173304497244814071505790566593206419759</span></div><div class="line"></div><div class="line"><span class="comment"># 二者差值 (p - q) = 121175219347395453721240713525179047984591561437374135042610848957151753264955644</span></div></pre></td></tr></table></figure>

<p>在使用Python和gmpy2的条件下，普通的个人笔记本电脑破解这个反例中的<code>N = p * q</code>只需不到0.2秒的时间。</p>
<h2 id="再谈质因数分解及数论">再谈质因数分解及数论</h2>
<p>在数学中恐怕很少有哪个问题像质因数分解这样简单但又令人着迷，任何一个小学文化程度的人都可以理解素数以及质因数分解的基本概念，同时又有诸多伟大的数学家和计算机科学家在为其倾注心力。到目前为止我们仍不敢断言自己已经完全了解了质因数分解这个问题，我们只知道大数的质因数分解非常困难，但我们并不清楚它到底有多困难，比如是否存在多项式时间复杂度的分解算法（是否属于P复杂度）。目前效率最高的算法是<a href="http://zh.wikipedia.org/wiki/%E6%99%AE%E9%80%9A%E6%95%B0%E5%9F%9F%E7%AD%9B%E9%80%89%E6%B3%95" target="_blank" rel="external">普通数域筛法</a>，其运行时间高于多项式时间，但低于指数时间，我们尚不知道是否存在更优的算法。</p>
<p>1994年，美国计算机科学家Peter Shor提出了一种出人意料的算法，即<a href="http://zh.wikipedia.org/wiki/%E7%A7%80%E7%88%BE%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">量子质因数分解算法</a>（又称Shor算法），该算法可以在多项式时间内完成大数的质因数分解，因而被看做该领域的一个重大突破；但Shor算法本质上是一个<a href="http://en.wikipedia.org/wiki/Quantum_algorithm" target="_blank" rel="external">量子算法</a>，不属于经典<a href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="external">图灵机</a>上的算法，只能在<a href="http://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F" target="_blank" rel="external">量子计算机</a>上运行。截止到目前（2014年），关于量子计算是否可行、量子计算机是否可实现等问题尚存在争议，IBM曾于2001年搭建了一台基于<a href="http://zh.wikipedia.org/wiki/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF" target="_blank" rel="external">核磁共振技术</a>的小型量子计算机并使用Shor算法将15分解为3和5的乘积，但有批评者认为这次实验其实并不是量子计算的真实演示。</p>
<p>总而言之，今天的我们仍旧可以对RSA等依赖于质因数分解的加密算法感到放心，包括量子计算在内，尚没有任何破解方法能够达到实用水平。但未来一切皆有可能，也许会有人发现可在经典图灵机上运行的多项式时间复杂度的质因数分解算法，也许有一天量子计算机和Shor算法会达到大规模商业化部署的水平。不论最终如何，这些潜在的可能性都始终激励着我们在相关领域中不断探索。</p>
<p>在数论领域中做出过巨大贡献的英国著名数学家<a href="http://zh.wikipedia.org/wiki/G%C2%B7H%C2%B7%E5%93%88%E4%BB%A3" target="_blank" rel="external">哈代</a>（Godfrey Harold Hardy）曾认为最美的数学应当没有任何实用价值，即所谓的“纯数学（pure mathematics）”，因此他对于自己钟爱一生的数论感到满意，因为在那个时代，数论几乎就是屠龙之术。在晚年著作《一个数学家的辩白》中，哈代这样写道：</p>
<blockquote>
<p>到目前为止，还尚未有人能够发现数论和相对论用于任何与战争有关的目的，而且在今后许多年，也不太可能会有人能够做到这一点。</p>
<p>No one has yet discovered any warlike purpose to be served by the theory of numbers or relativity, and it seems unlikely that anyone will do so for many years.</p>
</blockquote>
<p>然而事实上，就在哈代写下这句话的1940年，他的剑桥小学弟、伟大的计算机科学先驱<a href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5" target="_blank" rel="external">图灵</a>正在利用同样看似无用的数理逻辑和群论破解着纳粹德国的<a href="http://zh.wikipedia.org/wiki/Enigma" target="_blank" rel="external">Engima</a>，大洋彼岸的美国人也已经开始把玄虚飘渺的相对论和量子力学应用于制造原子弹的<a href="http://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%AE%A1%E5%88%92" target="_blank" rel="external">曼哈顿计划</a>。恐怕更令哈代意想不到的是，虽然普罗大众对数论乃至整个数学仍旧缺乏兴趣，但当今社会实际上已经离不开数论，没有数论，就没有今天的电子商务、网上银行和电子邮件系统；换言之，哈代理想中毫无实用价值的数论正在今天的社会中为我们创造财富、守护隐私、保障安全。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://www.coursera.org/course/crypto" target="_blank" rel="external">Cryptography I 课件</a> （作者：Dan Boneh）</li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">《RSA 算法原理（一）</a>、<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">（二）》</a> （作者：阮一峰）</li>
<li><a href="http://www.matrix67.com/blog/archives/5100" target="_blank" rel="external">《跨越千年的RSA算法》</a> （作者：Matrix67）</li>
<li><a href="http://www.matrix67.com/blog/archives/236" target="_blank" rel="external">《同余运算及其基本性质》</a> （作者：Matrix67）</li>
<li><a href="http://shoup.net/ntb/" target="_blank" rel="external"><em>A Computational Introduction to Number Theory and Algebra</em></a> （作者：Victor Shoup）</li>
<li><a href="http://en.wikipedia.org" target="_blank" rel="external">Wikipedia</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="历史">历史</h2>
<p>自<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E6%A3%92" target="_blank" rel="external">密码棒</a>和<a href="http://zh.wikipedia.org/wiki/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81" target="_blank" rel="external">凯撒密码</a>发明之后，人们在漫长的历史岁月中始终遵循着一套相同的加密、解密模式，即Alice使用一个<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5" target="_blank" rel="external">密钥</a>对<a href="http://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87" target="_blank" rel="external">明文</a>进行加密得到<a href="http://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87" target="_blank" rel="external">密文</a>，Bob收到密文后使用同样的密钥进行解密得到明文。其中加密和解密使用的是同一个密钥，这种模式称为“<a href="http://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="external">对称密码系统</a>”。显然，对称密码系统很容易理解，从技术层面上来讲也比较容易实现，但这种系统存在一个极为棘手的问题，即如何安全地保存和传递密钥，毕竟保存和传递本身也有可能被攻击或窃听。</p>
]]>
    
    </summary>
    
      <category term="密码学" scheme="http://sunxb10.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="RSA" scheme="http://sunxb10.github.io/tags/RSA/"/>
    
      <category term="密码学" scheme="http://sunxb10.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>
